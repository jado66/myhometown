// src/app/api/scheduled-texts/process/route.js
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import { v4 as uuidv4 } from "uuid";
import { sendTextWithStream } from "@/util/communication/sendTexts";
import {
  completeStream,
  sendMessageToStream,
} from "../../communications/send-texts/stream/route";

export const dynamic = "force-dynamic";
export const runtime = "nodejs";
export const maxDuration = 60;

export async function POST(req) {
  try {
    // Verify the request is from Supabase
    const authHeader = req.headers.get("Authorization");
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const token = authHeader.split(" ")[1];
    if (token !== process.env.SCHEDULED_TEXTS_WEBHOOK_SECRET) {
      return NextResponse.json({ error: "Invalid token" }, { status: 401 });
    }

    // Get the payload from the request
    const payload = await req.json();

    // For Supabase Edge Functions, the payload might be structured differently
    const record = payload.record || payload;

    if (!record || !record.id) {
      return NextResponse.json({ error: "Invalid payload" }, { status: 400 });
    }

    // Get the scheduled text details
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
    const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    const { data: scheduledText, error: fetchError } = await supabase
      .from("scheduled_texts")
      .select("*")
      .eq("id", record.id)
      .single();

    if (fetchError || !scheduledText) {
      console.error("Error fetching scheduled text:", fetchError);
      return NextResponse.json(
        {
          error: "Scheduled text not found",
          details: fetchError?.message,
        },
        { status: 404 }
      );
    }

    // Generate a message ID for tracking
    const messageId = uuidv4();

    try {
      // Parse recipients from JSON
      const recipients = JSON.parse(scheduledText.recipients);

      // Process messages sequentially
      for (const recipient of recipients) {
        try {
          const result = await sendTextWithStream({
            message: scheduledText.message_content,
            recipient: {
              phone: recipient.value || recipient.phone,
              name:
                recipient.label ||
                recipient.name ||
                `${recipient.firstName || ""} ${
                  recipient.lastName || ""
                }`.trim(),
            },
            mediaUrls: scheduledText.media_urls
              ? JSON.parse(scheduledText.media_urls)
              : [],
            messageId,
          });

          // Send status update to stream
          await sendMessageToStream(messageId, {
            type: "status",
            status: "success",
            recipient: recipient.value || recipient.phone,
            messageId,
            timestamp: new Date().toISOString(),
          });
        } catch (error) {
          console.error(
            `Error sending to ${recipient.value || recipient.phone}:`,
            error
          );

          // Send failure status to stream
          await sendMessageToStream(messageId, {
            type: "status",
            status: "failed",
            recipient: recipient.value || recipient.phone,
            error: error.message,
            messageId,
            timestamp: new Date().toISOString(),
          });
        }
      }

      // Mark stream as complete
      await completeStream(messageId);

      // Log the sent message for each recipient
      const { data: logData, error: logError } = await supabase
        .from("text_logs")
        .insert(
          recipients.map((recipient) => ({
            message_id: messageId,
            sender_id: scheduledText.user_id,
            recipient_phone: recipient.value || recipient.phone,
            recipient_contact_id: recipient.contactId || null,
            message_content: scheduledText.message_content,
            media_urls: scheduledText.media_urls,
            status: "sent",
            sent_at: new Date().toISOString(),
            owner_id: scheduledText.user_id,
            owner_type: "user",
            metadata: JSON.stringify({
              recipientName:
                recipient.label ||
                recipient.name ||
                `${recipient.firstName || ""} ${
                  recipient.lastName || ""
                }`.trim(),
              scheduledSend: true,
              scheduledId: scheduledText.id,
              scheduledTime: scheduledText.scheduled_time,
            }),
          }))
        );

      if (logError) {
        console.error("Error logging sent text:", logError);
      }

      // Delete the scheduled text since it's been processed
      const { error: deleteError } = await supabase
        .from("scheduled_texts")
        .delete()
        .eq("id", scheduledText.id);

      if (deleteError) {
        console.error("Error deleting scheduled text:", deleteError);
      }

      return NextResponse.json({
        success: true,
        messageId,
        scheduledTextId: scheduledText.id,
      });
    } catch (sendError) {
      console.error("Error sending scheduled text:", sendError);

      // Complete the stream in case of error
      await completeStream(messageId);

      return NextResponse.json(
        {
          error: "Failed to send text",
          details: sendError.message,
        },
        { status: 500 }
      );
    }
  } catch (error) {
    console.error("Unexpected error in scheduled texts processing:", error);
    return NextResponse.json(
      {
        error: "Internal server error",
        details: error.message,
      },
      { status: 500 }
    );
  }
}
